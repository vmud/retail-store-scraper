name: Multi-Agent PR Coordination

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]

permissions:
  contents: read
  pull-requests: write

jobs:
  detect-agent:
    name: Detect Agent & Label PR
    runs-on: ubuntu-latest
    outputs:
      agent: ${{ steps.detect.outputs.agent }}
    steps:
      - name: Detect agent from branch name
        id: detect
        env:
          HEAD_REF: ${{ github.head_ref }}
        run: |
          BRANCH="$HEAD_REF"
          AGENT="unknown"

          if [[ "$BRANCH" =~ /cc[0-9]- ]]; then
            AGENT="claude-code"
          elif [[ "$BRANCH" =~ /cursor- ]]; then
            AGENT="cursor"
          elif [[ "$BRANCH" =~ /copilot- ]]; then
            AGENT="copilot"
          elif [[ "$BRANCH" =~ /gemini- ]]; then
            AGENT="gemini"
          elif [[ "$BRANCH" =~ /aider- ]]; then
            AGENT="aider"
          elif [[ "$BRANCH" =~ /human- ]]; then
            AGENT="human"
          fi

          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          echo "Detected agent: $AGENT from branch: $BRANCH"

      - name: Apply agent label
        if: steps.detect.outputs.agent != 'unknown'
        uses: actions/github-script@v8
        with:
          script: |
            const agent = '${{ steps.detect.outputs.agent }}';
            const label = `agent:${agent}`;

            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: [label]
              });
              console.log(`Added label: ${label}`);
            } catch (error) {
              // Label might not exist, create it
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label,
                  color: 'c5def5',
                  description: `PR created by ${agent}`
                });
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: [label]
                });
              } catch (createError) {
                console.log(`Could not create/add label: ${createError.message}`);
              }
            }

  check-conflicts:
    name: Check PR Conflicts
    runs-on: ubuntu-latest
    needs: detect-agent
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Fetch all open PR branches
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          # Get list of open PRs (excluding current)
          PR_NUMBER="${{ github.event.pull_request.number }}"

          echo "Current PR: #$PR_NUMBER"
          echo "Checking for conflicts with other open PRs..."

          # Fetch the base branch
          git fetch origin -- "$BASE_REF"

      - name: Check merge conflicts with base
        id: base-conflict
        env:
          HEAD_REF: ${{ github.head_ref }}
          BASE_REF: ${{ github.base_ref }}
        run: |
          git fetch origin -- "$HEAD_REF"
          git checkout FETCH_HEAD

          # Try to merge base branch
          if git merge --no-commit --no-ff "origin/$BASE_REF" 2>/dev/null; then
            echo "conflict=false" >> $GITHUB_OUTPUT
            echo "No conflicts with base branch"
            git merge --abort 2>/dev/null || true
          else
            echo "conflict=true" >> $GITHUB_OUTPUT
            echo "Conflicts detected with base branch"
            git merge --abort 2>/dev/null || true
          fi

      - name: Check conflicts with other open PRs
        id: pr-conflicts
        uses: actions/github-script@v8
        with:
          script: |
            const currentPR = context.issue.number;
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              base: '${{ github.base_ref }}'
            });

            const otherPRs = prs.filter(pr => pr.number !== currentPR);
            console.log(`Found ${otherPRs.length} other open PRs targeting ${context.payload.pull_request.base.ref}`);

            // Fetch current PR files once (with pagination for >30 files)
            const currentFiles = await github.paginate(
              github.rest.pulls.listFiles,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: currentPR,
                per_page: 100
              }
            );
            const currentFilenames = new Set(currentFiles.map(f => f.filename));

            const conflictPRs = [];
            for (const pr of otherPRs) {
              // Get the files changed in the other PR (with pagination)
              const otherFiles = await github.paginate(
                github.rest.pulls.listFiles,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100
                }
              );

              const overlapping = otherFiles.filter(f => currentFilenames.has(f.filename));

              if (overlapping.length > 0) {
                conflictPRs.push({
                  number: pr.number,
                  title: pr.title,
                  files: overlapping.map(f => f.filename)
                });
              }
            }

            if (conflictPRs.length > 0) {
              let message = '## Potential Conflicts Detected\n\n';
              message += 'This PR modifies files that are also modified in other open PRs:\n\n';

              for (const pr of conflictPRs) {
                message += `### PR #${pr.number}: ${pr.title}\n`;
                message += 'Overlapping files:\n';
                for (const file of pr.files) {
                  message += `- \`${file}\`\n`;
                }
                message += '\n';
              }

              message += '**Recommendation**: Coordinate with the authors of these PRs to avoid merge conflicts.\n';

              // Add conflict label
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: currentPR,
                  labels: ['conflict:potential']
                });
              } catch (e) {
                console.log('Could not add conflict label');
              }

              // Post comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: currentPR,
                body: message
              });

              core.setOutput('has_conflicts', 'true');
              core.setOutput('conflict_count', conflictPRs.length);
            } else {
              console.log('No file overlaps with other open PRs');
              core.setOutput('has_conflicts', 'false');
              core.setOutput('conflict_count', '0');
            }

      - name: Add needs-rebase label if conflicting with base
        if: steps.base-conflict.outputs.conflict == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['needs:rebase']
              });
            } catch (e) {
              // Create label if it doesn't exist
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'needs:rebase',
                  color: 'fbca04',
                  description: 'PR needs to be rebased on latest main'
                });
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: ['needs:rebase']
                });
              } catch (createError) {
                console.log('Could not create/add label');
              }
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '## Merge Conflict with Base Branch\n\nThis PR has merge conflicts with `${{ github.base_ref }}`. Please merge the latest `${{ github.base_ref }}` into your branch to resolve conflicts.\n\n```bash\ngit fetch origin ${{ github.base_ref }}\ngit merge origin/${{ github.base_ref }}\n# Resolve conflicts\ngit push\n```'
            });

  # NOTE: Tests are run by the dedicated test.yml workflow on PRs.
  # Removed duplicate test job to reduce CI time by 50%.

  summary:
    name: PR Summary
    runs-on: ubuntu-latest
    needs: [detect-agent, check-conflicts]
    if: always()
    steps:
      - name: Generate summary
        uses: actions/github-script@v8
        with:
          script: |
            const agent = '${{ needs.detect-agent.outputs.agent }}';

            let summary = `## Multi-Agent PR Check Summary\n\n`;
            summary += `| Check | Status |\n`;
            summary += `|-------|--------|\n`;
            summary += `| Agent Detection | ${agent !== 'unknown' ? '✅ ' + agent : '⚠️ Unknown'} |\n`;
            summary += `| Conflict Check | ✅ Complete |\n`;
            summary += `| Tests | See test.yml workflow |\n`;

            console.log(summary);
